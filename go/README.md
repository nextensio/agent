# Agent lib and platforms

The agent code itself is compiled as a library, the goal is that this lib 
will be loaded as a CGO module from java (android) / swift (ios) / c# (Win)
platforms which implement a thin layer to just provide us with packets.

The platforms directory contains all the platforms that use the library and
create an agent binary for that platform. Today it has android and docker
as platforms, there will eventually be ios, windows, macos, linux in there.


## Android agent

### Compiling and running agent on emulator

To compile and deploy the android agent in an phone emulator on your laptop, do the following

1. Enable VT-X extensions on your VM/host/wherever - without that the emulator will not run.
   Google for how to enable VT-X for your choice of VM/laptop and you will find plenty of help

2. Install KVM - sudo apt install qemu-kvm

3. Install the android Studio. Do not install it using "snap install" or "apt-get install", 
   those always seem to end up with some issue or the other. Just follow the instructions
   at https://developer.android.com/studio/install to install. 

4. Install the android 'ndk' - ndk allows C/C++ applications to be compiled in the android
   studio, again enable ndk via the android studio, do not install it seperately / manually
   https://developer.android.com/studio/projects/install-ndk

   The SDK and NDK will all be in your <home>/Android/Sdk directory

6. Build the code by saying "./gradlew assembleDebug" in the platforms/android directory.
   The cgo stuff is all compiled in platforms/android/app/.cxx/ autogenerated directory. 
   Sometimes ive seen that a change in one of the go libraries does not recompile the 
   android code in the step above, its a TODO to figure out what exactly the scenario is
   and how to fix it with proper dependency settings etc.. Meanwhile I always do 
   "./gradlew clean" and then do a "./gradlew assembleDebug"
   
   A succesful build will generate ./app/build/outputs/apk/debug/app-debug.apk - that is
   the entire application bundle that we can install on a phone - we should be able to 
   download this from some place onto our phone and install it - of course this is till
   we officially get our app into a playstore etc..

7. To run an android emulator, do the following. 
   
   docker run --privileged -d --network kind -p 6080:6080 -p 5554:5554 -p 5555:5555 -e DEVICE="Samsung Galaxy S6" --name android budtmo/docker-android-x86-8.1

   The above will spin up an androind emulator as a docker container. Note the "--network kind"
   option above "assumes" that you have a kind based docker testbed with nextensio clusters and
   agents etc.. and we are connecting this android phone to that test cluster! 
   
   In your browser, type http://localhost:6080/ and you can see your phone!!

8. To copy the agent to the phone, do the below steps

   a) docker cp ./app/build/outputs/apk/debug/app-debug.apk android:/root/
   Note that the "android" is the name of the docker container we started in the previous step

   b) docker exec -it android /bin/bash to get into the container and install the app by saying
   "adb install /root/app-debug.apk" .. The next time you udate your app and want to install it
   again, you can say "adb install -r /root/app-debug.apk" (-r to re-install it)

   Now you should be able to see your app on the phone's app list !


### Connecting to nextensio

Once your app is installed on the emulator via the above steps, then do the following to make
your phone's traffic go via nextensio. Again we are assuming that the agent is connected to 
the kind nextensio testbed we have created (remember the --network kind option above to connect
the phone's wifi to the rest of the nextensio docker containers)

1. The nextensio agent tries to contact the following domains
   server.nextensio.net (controller) and gateway.testa.nextensio.net and gateway.testc.nextensio.net
   We dont have any dns server etc.. that serves these names, so we have to the below hacks to 
   get those names mapped - basically add those names to the "/etc/hosts" of android's linux
   In the docker container of the emulator, type the below commands inside the android docker container

   ```
   adb root
   adb remount
   adb shell 'echo "172.18.0.2 server.nextensio.net" >> /etc/hosts'
   adb shell 'echo "172.18.0.3 gateway.testa.nextensio.net" >> /etc/hosts'
   adb shell 'echo "172.18.0.4 gateway.testc.nextensio.net" >> /etc/hosts'
   adb shell "cat /etc/hosts" 
   ```

   The 172.18.x IP addresses are obtained from the /tmp/nextensio-kind/environment file which
   is generated when we create the nextensio kind testbed. Confirm your IPs with that file
   The last step "cat" will show whether the values your programmed are intact

2. Launch the nextensio app on the phone, DO NOT click on "AGENT ON" yet. Just have the 
   app running, thats all. We have to onboard the agent first before turning it on.

3. Lets onboard the agent as a "test1@nextensio.net" - there might already be a docker 
   container nxt_agent1 in the kind testbed onboarded as test1, so just kill it by saying
   'docker kill nxt_agent1' - two agents with the same userid must work, and there is
   code in there to ensure it works, but thats not tested yet, thats a TODO for another day

   Now open a browser on the phone, "localhost:8180" and you will see a login screen. If it
   says you are already logged in, just logout. And then the username is test1@nextensio.net
   and password is LetMeIn123. This will basically contact Okta and authenticate the 
   user and get the access token etc.. The okta domain it contacts is hard coded today, its 
   a TODO to figure out how to make it configurable - maybe a configuration option in the  
   agent UI ?

4. Once the webpage says you are logged in, then you have authenticated the agent and now
   the agent would have dialled a connection to the gateway, now you are ready to turn on
   the VPN. So go to the agent app again and click on "TURN ON" and henceforth all the
   traffic from the phone will go via nextensio. Open a browser and browse and enjoy!

5. To stop traffic going via nextensio, there is no OFF button in the agent today, just
   open the system settings, select the network option, go down to the VPN section and
   click on nextensio and say off.

### Code Organization

The code is organized such that the android "native" stuff (java) basically handles as
minimal stuff as possible - app front end, enabling the vpnService etc.. and then hands
off all the nextensio work to the golang agent. So the native/java stuff should not have
any nextensio specific stuff in there

#### Java code

The app/src/main/java/nextensio/agent/ has the java code for the agent. It has two classes
NxtAgent and NxtAgentService. The class NxtAgent handles the "activity" (in android lingo)
of starting up the app when someone clicks on it etc.. The class NxtAgentService handles the
"service" (again in android lingo) when the app asks for a service from androind (vpnService)
If you grep for NxtAgent and NxtAgentService in *.xml in the platforms/android directory, 
you will see those names embedded in various xml files, thats how the android system is told
what java code to run when the user lanuches an app or asks for vpn to be turned on etc..

Inside the NxtAgent code, we first load the shared libraries which implement the golang code,
and then we call nxtInit() which is declared in the same file as "private native", which 
means its a "JNI" (Java Native Interface) API - which means its not part of the jvm, but
its a library call outside the JVM. We will talk about how this JNI is made in a bit

Inside the NxtAgentService code, we also load the shared libraries one time - looks like
the NxtAgent and NxtAgentService can be called by androind independently / out-of-order
and hence we cant rely on one loading the services before the other etc.. And then this
code handles the VPN enablement part, and when VPN is enabled it creates a vpnService,
gets the file descriptor for that service and then passes it onto golang code by calling
nxtOn(fd) - nxtOn is again a JNI API defined as 'private native' in that file

#### JNI and Golang code

The golang code resides in this repository's agent/ and shared/ directory, there is 
a small shim layer in app/tools/libnxt-go/apis.go that calls into the agent code.
These golang APIs are compiled into C code usig cgo (refer to the Makefile there). And
they are then exposed as JNI APIs using the jni.c file - we can directly load the 
golang API names from cgo because JNI expects the API names to be in a particular 
format concatenating the class heirarchy etc.. as you can see in jni.c

The golang nxtInit() calls AgentInit() which initializes the agent. And nxtOn(fd)
calls AgentIface() which creates an packet interface in the agent using the supplied
file descriptor

## Connector

The connector is expected to run on one platform which is linux, and we will
most likely package the connector as a docker container
