# Agent lib and platforms

The agent code itself is compiled as a library - we have a go agent and a rust agent.
The go agent consumes a bit too much memory than we would like, so we have a rust agent
too. The go agent will be loaded as a CGO module from java (android) / swift (ios) / c# (Win)
platforms which implement a thin layer to just provide us with packets. Similarly, the
rust agent is compiled into a C library which is used as a C library just like the CGO
agent above. 

The platforms directory contains all the platforms that use the library and
create an agent binary for that platform. Today it has android and docker
as platforms, there will eventually be ios, windows, macos, linux in there. As of today
there is a platform directory for rust and go seperately, and most of the java/swift
code there is common - its a TBD whther we will maintain both go and Rust versons in
which case we have to keep the common java/swift stuff in some place common, or we just
retire the go version altogether because its not usable on ios anyways because of memory
constraints.

## Rust / Go common notes for compiling the code

Refer to https://gitlab.com/nextensio/common/-/blob/master/README.md - there are some
steps to be done before we can build the code here, the steps are outlined in that readme

## Apple agent

#### Golang notes

The CGO compiled library is called libnxt-go.a

#### Rust notes

The code is in agent/rust - the "common" code (common across platforms) is in agent/rust/agent
and the agent/rust/platform directory has code for apple/android etc.. The Rust agent has to put
the file descriptor in NON-BLOCKING mode


We are following instructions mentioned here - https://medium.com/visly/rust-on-ios-39f799b3c1dd
The steps are as below

0. Install rust: ```curl https://sh.rustup.rs -sSf | sh``` (https://www.rust-lang.org/tools/install)
   Make sure you have at least rust 1.51 toolchain .. this is because we need a 
   feature (https://github.com/rust-lang/cargo/issues/4866) which is only in >= 1.51 toolchain

1. Add rust targets
 
   Although the apple example link talks about armv7 and i386 targets, looks like
   they are unavailable now - maybe deprecated chipsets ? So all that will work is the below targets
    ```rustup target add aarch64-apple-ios x86_64-apple-ios aarch64-apple-darwin x86_64-apple-darwin```

   Install lipo: ```cargo install cargo-lipo```

2. Build the agent
   Run ```cargo lipo --release``` or in the 
   ```cp /home/gopa/NXT/agent/rust/target/universal/release/libnextensio.a platforms/ios/.../lib"

   The Rust compiled library is called libnxt.a. Note that in the golang version, the NextensioGoBridge/Makefile
   compiles the apis.go file into C to create libnxt.a. But here in the rust version, we let the Rust
   build system (cargo) compile apple stuff in this step and as per the medium.com link, we just need to 
   pick the resulting library and put it in some place (mentioned in the link) in the apple directory.
   If you look at platforms/android/app/tools/libnxt/Makefile, you can see a step there where we let the
   makefile copy the library automatically to the required destination (assuming the library is built already).
   So something like that can be done if a lil more automation is desired. Eventually we also have to 
   automatically do the cargo build also from the Makefile before the copy is tried - thats all easy and
   can happen over time

Note: We can ignore the "bindgen" steps in the medium.com link - that is if we want to automatically
generate C header files (the nxt.h file) from the rust code. For now its just a handful of apis and
we are manually hand coding it in nxt.h. But in the long run yes its a good idea to let bindgen 
auto generate it 

## Android agent

### Compiling and running agent on emulator

To compile and deploy the android agent in an phone emulator on your laptop, do the following

1. Enable VT-X extensions on your VM/host/wherever - without that the emulator will not run.
   Google for how to enable VT-X for your choice of VM/laptop and you will find plenty of help

2. Install KVM - sudo apt install qemu-kvm

3. Install the android Studio. Do not install it using "snap install" or "apt-get install", 
   those always seem to end up with some issue or the other. Just follow the instructions
   at https://developer.android.com/studio/install to install. 

4. Install the android 'ndk' - ndk allows C/C++ applications to be compiled in the android
   studio, again enable ndk via the android studio, do not install it seperately / manually
   https://developer.android.com/studio/projects/install-ndk

   The SDK and NDK will all be in your <home>/Android/Sdk directory

6. Build the code by saying "./gradlew assembleDebug" in the platforms/android directory.
   The cgo stuff is all compiled in platforms/android/app/.cxx/ autogenerated directory. 
   
   A succesful build will generate ./app/build/outputs/apk/debug/app-debug.apk - that is
   the entire application bundle that we can install on a phone - we should be able to 
   download this from some place onto our phone and install it - of course this is till
   we officially get our app into a playstore etc..

7. To run an android emulator, do the following. 
   
   docker run --privileged -d --network kind -p 6080:6080 -p 5554:5554 -p 5555:5555 -e DEVICE="Samsung Galaxy S6" --name android budtmo/docker-android-x86-8.1

   The above will spin up an androind emulator as a docker container. Note the "--network kind"
   option above "assumes" that you have a kind based docker testbed with nextensio clusters and
   agents etc.. and we are connecting this android phone to that test cluster! 
   
   In your browser, type http://localhost:6080/ and you can see your phone!!

8. To copy the agent to the phone, do the below steps

   a) docker cp ./app/build/outputs/apk/debug/app-debug.apk android:/root/
   Note that the "android" is the name of the docker container we started in the previous step

   b) docker exec -it android /bin/bash to get into the container and install the app by saying
   "adb install /root/app-debug.apk" .. The next time you udate your app and want to install it
   again, you can say "adb install -r /root/app-debug.apk" (-r to re-install it)

   Now you should be able to see your app on the phone's app list !

#### Golang notes

The golang agent has to put the file descriptor in BLOCKING mode

#### Rust notes

The code is in agent/rust - the "common" code (common across platforms) is in agent/rust/agent
and the agent/rust/platform directory has code for apple/android etc.. The Rust agent has to put
the file descriptor in NON-BLOCKING mode

We are following instructions mentioned here - https://medium.com/visly/rust-on-android-19f34a2fb43
The steps are as below

0. Install rust: ```curl https://sh.rustup.rs -sSf | sh``` (https://www.rust-lang.org/tools/install)
   Use the "beta" toolchain for now, it will become a released version on march 25, just few days
   away - ```rustup toolchain install beta``` and ```rustup default beta``` .. this is because we need a 
   feature (https://github.com/rust-lang/cargo/issues/4866) which is right now only in beta

1. Add rust targets
   ```rustup target add aarch64-linux-android armv7-linux-androideabi i686-linux-android x86_64-linux-android```

2. Create standalone toolchain even though the android ndk says it is not necessary, maybe
   it isnt, I just havent checked

   ```
   <ndk path>/build/tools/make_standalone_toolchain.py --api 26 --arch arm64 --install-dir ~/.NDK/arm64;
   <ndk path>/build/tools/make_standalone_toolchain.py --api 26 --arch arm --install-dir ~/.NDK/arm;
   <ndk path>/build/tools/make_standalone_toolchain.py --api 26 --arch x86 --install-dir ~/.NDK/x86;
   <ndk path>/build/tools/make_standalone_toolchain.py --api 26 --arch x86_64 --install-dir ~/.NDK/x86_64;
   ```

3. Add the below to ~/.cargo/config

   ```
   [build]
   target = "x86_64-unknown-linux-gnu"

   [target.aarch64-linux-android]
   ar = ".NDK/arm64/bin/aarch64-linux-android-ar"
   linker = ".NDK/arm64/bin/aarch64-linux-android-clang"

   [target.armv7-linux-androideabi]
   ar = ".NDK/arm/bin/arm-linux-androideabi-ar"
   linker = ".NDK/arm/bin/arm-linux-androideabi-clang"

   [target.i686-linux-android]
   ar = ".NDK/x86/bin/i686-linux-android-ar"
   linker = ".NDK/x86/bin/i686-linux-android-clang"

   [target.x86_64-linux-android]
   ar = ".NDK/x86_64/bin/x86_64-linux-android-ar"
   linker = ".NDK/x86_64/bin/x86_64-linux-android-clang"
   ```

4. Add the .NDK binary to the PATH

   ```export PATH=$PATH:~/.NDK/arm64/bin/:~/.NDK/arm/bin/:~/.NDK/x86/bin/:~/.NDK/x86_64/bin/```

5. Build the agent for all the targets

    ```
    cargo build --target aarch64-linux-android --release
    cargo build --target armv7-linux-androideabi --release
    cargo build --target i686-linux-android --release
    cargo build --target x86_64-linux-android --release
    ```

### Connecting to nextensio

Once your app is installed on the emulator via the above steps, then do the following to make
your phone's traffic go via nextensio. Again we are assuming that the agent is connected to 
the kind nextensio testbed we have created (remember the --network kind option above to connect
the phone's wifi to the rest of the nextensio docker containers)

1. The nextensio agent tries to contact the following domains
   server.nextensio.net (controller) and gateway.testa.nextensio.net and gateway.testc.nextensio.net
   We dont have any dns server etc.. that serves these names, so we have to the below hacks to 
   get those names mapped - basically add those names to the "/etc/hosts" of android's linux
   In the docker container of the emulator, type the below commands inside the android docker container

   ```
   adb root
   adb remount
   adb shell 'echo "172.18.0.2 server.nextensio.net" >> /etc/hosts'
   adb shell 'echo "172.18.0.3 gateway.testa.nextensio.net" >> /etc/hosts'
   adb shell 'echo "172.18.0.4 gateway.testc.nextensio.net" >> /etc/hosts'
   adb shell "cat /etc/hosts" 
   ```

   The 172.18.x IP addresses are obtained from the /tmp/nextensio-kind/environment file which
   is generated when we create the nextensio kind testbed. Confirm your IPs with that file
   The last step "cat" will show whether the values your programmed are intact

2. Launch the nextensio app on the phone, DO NOT click on "AGENT ON" yet. Just have the 
   app running, thats all. We have to onboard the agent first before turning it on.

3. Lets onboard the agent as a "test1@nextensio.net" - there might already be a docker 
   container nxt_agent1 in the kind testbed onboarded as test1, so just kill it by saying
   'docker kill nxt_agent1' - two agents with the same userid must work, and there is
   code in there to ensure it works, but thats not tested yet, thats a TODO for another day

   Now open a browser on the phone, "localhost:8180" and you will see a login screen. If it
   says you are already logged in, just logout. And then the username is test1@nextensio.net
   and password is LetMeIn123. This will basically contact Okta and authenticate the 
   user and get the access token etc.. The okta domain it contacts is hard coded today, its 
   a TODO to figure out how to make it configurable - maybe a configuration option in the  
   agent UI ?

4. Once the webpage says you are logged in, then you have authenticated the agent and now
   the agent would have dialled a connection to the gateway, now you are ready to turn on
   the VPN. So go to the agent app again and click on "TURN ON" and henceforth all the
   traffic from the phone will go via nextensio. Open a browser and browse and enjoy!

5. To stop traffic going via nextensio, there is no OFF button in the agent today, just
   open the system settings, select the network option, go down to the VPN section and
   click on nextensio and say off.

### Code Organization

The code is organized such that the android "native" stuff (java) basically handles as
minimal stuff as possible - app front end, enabling the vpnService etc.. and then hands
off all the nextensio work to the golang agent. So the native/java stuff should not have
any nextensio specific stuff in there

#### Java code

The app/src/main/java/nextensio/agent/ has the java code for the agent. It has two classes
NxtAgent and NxtAgentService. The class NxtAgent handles the "activity" (in android lingo)
of starting up the app when someone clicks on it etc.. The class NxtAgentService handles the
"service" (again in android lingo) when the app asks for a service from androind (vpnService)
If you grep for NxtAgent and NxtAgentService in *.xml in the platforms/android directory, 
you will see those names embedded in various xml files, thats how the android system is told
what java code to run when the user lanuches an app or asks for vpn to be turned on etc..

Inside the NxtAgent code, we first load the shared libraries which implement the golang code,
and then we call nxtInit() which is declared in the same file as "private native", which 
means its a "JNI" (Java Native Interface) API - which means its not part of the jvm, but
its a library call outside the JVM. We will talk about how this JNI is made in a bit

Inside the NxtAgentService code, we also load the shared libraries one time - looks like
the NxtAgent and NxtAgentService can be called by androind independently / out-of-order
and hence we cant rely on one loading the services before the other etc.. And then this
code handles the VPN enablement part, and when VPN is enabled it creates a vpnService,
gets the file descriptor for that service and then passes it onto golang code by calling
nxtOn(fd) - nxtOn is again a JNI API defined as 'private native' in that file

#### JNI and Golang code

The golang code resides in this repository's agent/ and shared/ directory, there is 
a small shim layer in app/tools/libnxt-go/apis.go that calls into the agent code.
These golang APIs are compiled into C code usig cgo (refer to the Makefile there). And
they are then exposed as JNI APIs using the jni.c file - we can directly load the 
golang API names from cgo because JNI expects the API names to be in a particular 
format concatenating the class heirarchy etc.. as you can see in jni.c

The golang nxtInit() calls AgentInit() which initializes the agent. And nxtOn(fd)
calls AgentIface() which creates an packet interface in the agent using the supplied
file descriptor

## Connector

The connector is expected to run on one platform which is linux, and we will
most likely package the connector as a docker container

